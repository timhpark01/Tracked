---
phase: 02-core-tracking
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/features/profiles/services/profiles.service.ts
  - src/features/profiles/hooks/useMyProfile.ts
  - src/features/profiles/hooks/useUpdateProfile.ts
  - src/features/profiles/components/ProfileForm.tsx
  - src/features/profiles/components/AvatarPicker.tsx
  - src/features/profiles/index.ts
  - app/(app)/profile.tsx
  - app/(app)/profile/edit.tsx
autonomous: true

must_haves:
  truths:
    - "User can see their profile (username, bio, avatar)"
    - "User can edit their profile and see changes saved"
    - "User can pick and upload a new avatar"
    - "Profile persists across app restarts"
  artifacts:
    - path: "src/features/profiles/services/profiles.service.ts"
      provides: "getProfile, updateProfile functions"
      min_lines: 30
    - path: "src/features/profiles/hooks/useMyProfile.ts"
      provides: "useMyProfile hook for current user"
      min_lines: 15
    - path: "src/features/profiles/hooks/useUpdateProfile.ts"
      provides: "useUpdateProfile mutation hook"
      min_lines: 25
    - path: "app/(app)/profile.tsx"
      provides: "Profile view screen"
      min_lines: 40
    - path: "app/(app)/profile/edit.tsx"
      provides: "Profile edit screen"
      min_lines: 50
  key_links:
    - from: "app/(app)/profile.tsx"
      to: "useMyProfile"
      via: "hook call"
      pattern: "useMyProfile\\(\\)"
    - from: "src/features/profiles/hooks/useUpdateProfile.ts"
      to: "src/lib/storage.ts"
      via: "avatar upload"
      pattern: "uploadAvatar"
---

<objective>
Build the complete Profile feature with service layer, hooks, and screens for viewing and editing user profiles.

Purpose: Users need to create and manage their profile (PROF-01, PROF-02, PROF-03, PROF-04, PROF-05). This is the first feature users interact with after signup.
Output: Profile service, query/mutation hooks, form components, and screens for viewing and editing profiles.
</objective>

<execution_context>
@/Users/tim/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-tracking/02-RESEARCH.md

# Phase 1 patterns
@src/features/auth/hooks/useAuth.ts
@src/features/auth/services/auth.service.ts
@src/lib/supabase.ts
@src/types/database.ts

# Phase 2 infrastructure (from 02-01)
# @src/lib/storage.ts (will exist after 02-01)
# @src/components/forms/index.ts (will exist after 02-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create profile service and hooks</name>
  <files>
    src/features/profiles/services/profiles.service.ts
    src/features/profiles/hooks/useMyProfile.ts
    src/features/profiles/hooks/useUpdateProfile.ts
    src/features/profiles/index.ts
  </files>
  <action>
1. Create `src/features/profiles/services/profiles.service.ts`:
   ```typescript
   import { supabase } from '@/lib/supabase'
   import type { Database } from '@/types/database'

   type Profile = Database['public']['Tables']['profiles']['Row']
   type ProfileUpdate = Database['public']['Tables']['profiles']['Update']

   export async function getProfile(userId: string): Promise<Profile | null> {
     const { data, error } = await supabase
       .from('profiles')
       .select('*')
       .eq('id', userId)
       .single()

     if (error && error.code !== 'PGRST116') throw error // PGRST116 = not found
     return data
   }

   export async function updateProfile(userId: string, updates: ProfileUpdate): Promise<Profile> {
     const { data, error } = await supabase
       .from('profiles')
       .update(updates)
       .eq('id', userId)
       .select()
       .single()

     if (error) throw error
     return data
   }

   export async function createProfile(profile: { id: string; username: string }): Promise<Profile> {
     const { data, error } = await supabase
       .from('profiles')
       .insert(profile)
       .select()
       .single()

     if (error) throw error
     return data
   }
   ```

2. Create `src/features/profiles/hooks/useMyProfile.ts`:
   - Use `useQuery` with key `['my-profile']`
   - Get user from `useAuth()`
   - Fetch profile using `getProfile(user.id)`
   - `enabled: !!user`

3. Create `src/features/profiles/hooks/useUpdateProfile.ts`:
   - Use `useMutation`
   - Accept `{ username?, bio?, avatarUri? }` as input
   - If `avatarUri` provided, call `uploadAvatar(userId, avatarUri)` to get URL
   - Call `updateProfile` with the updates
   - On success, invalidate `['my-profile']` and `['profile', userId]`

4. Create `src/features/profiles/index.ts`:
   ```typescript
   export { useMyProfile } from './hooks/useMyProfile'
   export { useUpdateProfile } from './hooks/useUpdateProfile'
   export * from './services/profiles.service'
   ```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Files exist: `ls src/features/profiles/`
  </verify>
  <done>
Profile service exports getProfile, updateProfile, createProfile. Hooks useMyProfile and useUpdateProfile ready for screens.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create profile form components</name>
  <files>
    src/features/profiles/components/ProfileForm.tsx
    src/features/profiles/components/AvatarPicker.tsx
  </files>
  <action>
1. Create `src/features/profiles/components/AvatarPicker.tsx`:
   ```typescript
   import { View, Image, Pressable, Text } from 'react-native'
   import { pickImage } from '@/lib/storage'

   interface AvatarPickerProps {
     currentUrl: string | null
     onPick: (uri: string) => void
     size?: number
   }

   export function AvatarPicker({ currentUrl, onPick, size = 96 }: AvatarPickerProps) {
     const handlePick = async () => {
       const uri = await pickImage()
       if (uri) onPick(uri)
     }

     return (
       <Pressable onPress={handlePick} className="items-center">
         {currentUrl ? (
           <Image
             source={{ uri: currentUrl }}
             className="rounded-full bg-gray-200"
             style={{ width: size, height: size }}
           />
         ) : (
           <View
             className="rounded-full bg-gray-200 items-center justify-center"
             style={{ width: size, height: size }}
           >
             <Text className="text-gray-500 text-2xl">+</Text>
           </View>
         )}
         <Text className="text-blue-500 mt-2">Change Photo</Text>
       </Pressable>
     )
   }
   ```

2. Create `src/features/profiles/components/ProfileForm.tsx`:
   - Props: `initialData?: { username, bio }`, `onSubmit`, `isLoading`
   - Zod schema: `username` (required, 3-30 chars, alphanumeric + underscore), `bio` (optional, max 500 chars)
   - Use `useForm` with `zodResolver`
   - Use `ControlledInput` for username
   - Use `ControlledTextArea` for bio
   - Submit button with loading state
   - NativeWind styling matching auth screens
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Files exist: `ls src/features/profiles/components/`
  </verify>
  <done>
AvatarPicker shows current avatar and allows picking new one. ProfileForm validates username/bio and handles submission.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create profile screens</name>
  <files>
    app/(app)/profile.tsx
    app/(app)/profile/edit.tsx
    app/(app)/profile/_layout.tsx
  </files>
  <action>
1. Create `app/(app)/profile/_layout.tsx`:
   - Simple Stack layout: `<Stack screenOptions={{ headerShown: true }} />`

2. Create `app/(app)/profile.tsx` (view profile screen):
   - Use `useMyProfile()` to get profile data
   - Show loading state while fetching
   - Display avatar (Image or placeholder), username, bio
   - "Edit Profile" button linking to `/profile/edit`
   - Handle case where profile doesn't exist yet (new user) - show "Complete Your Profile" CTA
   - NativeWind styling: centered layout, proper spacing

3. Create `app/(app)/profile/edit.tsx` (edit profile screen):
   - Use `useMyProfile()` to get current data
   - Use `useUpdateProfile()` for mutations
   - Local state for `avatarUri` (pending upload)
   - Show `AvatarPicker` with current avatar URL or pending URI
   - Show `ProfileForm` with current username/bio
   - On form submit:
     1. Call mutation with `{ ...formData, avatarUri }`
     2. On success, navigate back to profile
     3. On error, show error message
   - Save button disabled while loading

4. Update `app/(app)/index.tsx`:
   - Add "Profile" link/button to navigate to `/profile`
   - Keep existing logout button
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Files exist: `ls app/\(app\)/profile/`
App starts: `npx expo start` (manual check)
  </verify>
  <done>
Profile tab shows user profile with avatar, username, bio. Edit screen allows updating all fields including avatar upload.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - compiles without errors
2. `ls src/features/profiles/` - service, hooks, components directories exist
3. `ls app/\(app\)/profile/` - profile screens exist
4. Manually test: Login -> Profile -> Edit -> Save -> Changes persist
</verification>

<success_criteria>
- Profile service with getProfile, updateProfile, createProfile functions
- useMyProfile hook returns current user's profile
- useUpdateProfile mutation handles avatar upload + profile updates
- Profile view screen shows avatar, username, bio
- Profile edit screen allows editing all fields with validation
- Avatar picker launches image library and returns selected image
- Changes persist after save and across app restarts
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-tracking/02-02-SUMMARY.md`
</output>
